name: üìä Monitoring & Health Checks

on:
  schedule:
    # Run every 15 minutes
    - cron: '*/15 * * * *'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to monitor'
        required: true
        default: 'production'
        type: choice
        options:
          - staging
          - production
          - both

env:
  NODE_VERSION: '20'

jobs:
  health-check:
    name: üè• Health Check
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        environment: 
          - ${{ github.event.inputs.environment == 'both' && 'staging' || github.event.inputs.environment || 'production' }}
          - ${{ github.event.inputs.environment == 'both' && 'production' || '' }}
      fail-fast: false
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üîß Setup environment variables
        run: |
          if [ "${{ matrix.environment }}" = "production" ]; then
            echo "APP_URL=${{ secrets.PRODUCTION_APP_URL }}" >> $GITHUB_ENV
            echo "ENVIRONMENT=production" >> $GITHUB_ENV
          elif [ "${{ matrix.environment }}" = "staging" ]; then
            echo "APP_URL=${{ secrets.STAGING_APP_URL }}" >> $GITHUB_ENV
            echo "ENVIRONMENT=staging" >> $GITHUB_ENV
          fi
      
      - name: üè• Basic health check
        id: health
        run: |
          echo "üè• Checking health of ${{ matrix.environment }} environment..."
          
          # Basic URL check
          if curl -f -s --max-time 30 "$APP_URL" > /dev/null; then
            echo "‚úÖ App is responding"
            echo "status=healthy" >> $GITHUB_OUTPUT
          else
            echo "‚ùå App is not responding"
            echo "status=unhealthy" >> $GITHUB_OUTPUT
          fi
      
      - name: üîß API endpoint checks
        if: steps.health.outputs.status == 'healthy'
        run: |
          echo "üîß Testing API endpoints..."
          
          # Test configuration endpoint
          CONFIG_RESPONSE=$(curl -s -w "%{http_code}" "$APP_URL/api/test-integration?type=config")
          CONFIG_STATUS=${CONFIG_RESPONSE: -3}
          
          if [ "$CONFIG_STATUS" = "200" ]; then
            echo "‚úÖ Configuration endpoint healthy"
          else
            echo "‚ùå Configuration endpoint failed (HTTP $CONFIG_STATUS)"
          fi
          
          # Test script endpoint
          SCRIPT_RESPONSE=$(curl -s -w "%{http_code}" "$APP_URL/visual-search-script.js")
          SCRIPT_STATUS=${SCRIPT_RESPONSE: -3}
          
          if [ "$SCRIPT_STATUS" = "200" ]; then
            echo "‚úÖ Script endpoint healthy"
          else
            echo "‚ùå Script endpoint failed (HTTP $SCRIPT_STATUS)"
          fi
      
      - name: üóÑÔ∏è Database connectivity check
        if: steps.health.outputs.status == 'healthy'
        run: |
          echo "üóÑÔ∏è Checking database connectivity..."
          
          # This would require setting up a health check endpoint in your app
          DB_RESPONSE=$(curl -s -w "%{http_code}" "$APP_URL/api/health/database" || echo "000")
          DB_STATUS=${DB_RESPONSE: -3}
          
          if [ "$DB_STATUS" = "200" ]; then
            echo "‚úÖ Database connection healthy"
          else
            echo "‚ö†Ô∏è Database health check not available or failed"
          fi
      
      - name: üìä Performance metrics
        if: steps.health.outputs.status == 'healthy'
        run: |
          echo "üìä Collecting performance metrics..."
          
          # Measure response time
          RESPONSE_TIME=$(curl -o /dev/null -s -w "%{time_total}" "$APP_URL")
          echo "‚è±Ô∏è Response time: ${RESPONSE_TIME}s"
          
          # Check if response time is acceptable (< 5 seconds)
          if (( $(echo "$RESPONSE_TIME < 5.0" | bc -l) )); then
            echo "‚úÖ Response time acceptable"
          else
            echo "‚ö†Ô∏è Response time slow: ${RESPONSE_TIME}s"
          fi
      
      - name: üì¢ Alert on failure
        if: steps.health.outputs.status == 'unhealthy'
        run: |
          echo "üö® ALERT: ${{ matrix.environment }} environment is unhealthy!"
          echo "App URL: $APP_URL"
          echo "Timestamp: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          
          # Here you could integrate with alerting services like:
          # - Slack webhook
          # - Discord webhook
          # - Email notifications
          # - PagerDuty
          # - etc.

  firebase-health:
    name: üî• Firebase Health Check
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        environment: [staging, production]
      fail-fast: false
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: üì¶ Install dependencies
        run: npm ci
      
      - name: üîß Setup Firebase credentials
        run: |
          if [ "${{ matrix.environment }}" = "production" ]; then
            echo "FIREBASE_PROJECT_ID=${{ secrets.PRODUCTION_FIREBASE_PROJECT_ID }}" >> $GITHUB_ENV
            echo "FIREBASE_CLIENT_EMAIL=${{ secrets.PRODUCTION_FIREBASE_CLIENT_EMAIL }}" >> $GITHUB_ENV
            echo "FIREBASE_PRIVATE_KEY=${{ secrets.PRODUCTION_FIREBASE_PRIVATE_KEY }}" >> $GITHUB_ENV
          else
            echo "FIREBASE_PROJECT_ID=${{ secrets.STAGING_FIREBASE_PROJECT_ID }}" >> $GITHUB_ENV
            echo "FIREBASE_CLIENT_EMAIL=${{ secrets.STAGING_FIREBASE_CLIENT_EMAIL }}" >> $GITHUB_ENV
            echo "FIREBASE_PRIVATE_KEY=${{ secrets.STAGING_FIREBASE_PRIVATE_KEY }}" >> $GITHUB_ENV
          fi
      
      - name: üî• Test Firebase connection
        run: |
          echo "üî• Testing Firebase connection for ${{ matrix.environment }}..."
          
          # Create a simple test script to check Firebase connectivity
          cat > test-firebase.js << 'EOF'
          import { initializeApp, cert } from 'firebase-admin/app';
          import { getFirestore } from 'firebase-admin/firestore';
          
          try {
            const app = initializeApp({
              credential: cert({
                projectId: process.env.FIREBASE_PROJECT_ID,
                clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
                privateKey: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
              }),
            });
            
            const firestore = getFirestore(app);
            
            // Test basic connectivity
            const testDoc = await firestore.collection('health-check').doc('test').get();
            console.log('‚úÖ Firebase connection successful');
            process.exit(0);
          } catch (error) {
            console.error('‚ùå Firebase connection failed:', error.message);
            process.exit(1);
          }
          EOF
          
          node test-firebase.js
        env:
          FIREBASE_PROJECT_ID: ${{ env.FIREBASE_PROJECT_ID }}
          FIREBASE_CLIENT_EMAIL: ${{ env.FIREBASE_CLIENT_EMAIL }}
          FIREBASE_PRIVATE_KEY: ${{ env.FIREBASE_PRIVATE_KEY }}

  performance-monitoring:
    name: ‚ö° Performance Monitoring
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event.inputs.environment != ''
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: ‚ö° Lighthouse CI
        run: |
          echo "‚ö° Running Lighthouse performance tests..."
          
          # Install Lighthouse CI
          npm install -g @lhci/cli
          
          # Run Lighthouse tests (if you have LHCI configured)
          # lhci autorun || echo "Lighthouse CI not configured"
          
          echo "üìä Performance monitoring completed"
      
      - name: üìä Generate monitoring report
        run: |
          echo "üìä Performance Monitoring Report"
          echo "================================"
          echo "Timestamp: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo "Monitored environments: production, staging"
          echo "Next check: $(date -u -d '+15 minutes' +"%Y-%m-%d %H:%M:%S UTC")"

  summary:
    name: üìã Monitoring Summary
    runs-on: ubuntu-latest
    needs: [health-check, firebase-health, performance-monitoring]
    if: always()
    
    steps:
      - name: üìã Generate summary
        run: |
          echo "üìã Monitoring Summary"
          echo "===================="
          echo "Health Check: ${{ needs.health-check.result }}"
          echo "Firebase Health: ${{ needs.firebase-health.result }}"
          echo "Performance: ${{ needs.performance-monitoring.result }}"
          echo ""
          
          if [ "${{ needs.health-check.result }}" = "success" ] && \
             [ "${{ needs.firebase-health.result }}" = "success" ]; then
            echo "‚úÖ All systems healthy"
          else
            echo "‚ö†Ô∏è Some systems need attention"
          fi
